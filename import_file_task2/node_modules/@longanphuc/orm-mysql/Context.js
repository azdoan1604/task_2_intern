const Connected = require("./Connect")
class Context{
    constructor($class){
        this.class = $class;
        this.sql = [""];        
        this.param = [];
        this.bracket = ""
    }
    async select (select = "*"){
        let table = new this.class().$table
        if(typeof select == "string"){
            if(select != "*")
                select = "`" +table+ "`." + "`" + select + "`"
            else{
                select = "`" +table+ "`.*"
            }
        }else{
            select.forEach((e,i)=>{select[i] ="`" +table+ "`." +  "`" + e + "`"})
        }
        this.sql[0] = "select "+(typeof select == "string"?select:select.join(","))+" from `" + table + "`"
        let rs = []
        let data = await Connected(this.sql.join(" "),this.param)
        data[0].forEach(element => {
            let model = new this.class()
            for (const [key, value] of Object.entries(element)) {
                model[key] = value
            }
            rs.push(model)
        });
        this.sql = [""]
        return rs
    }

    where(column,operator,value){
        if(value == undefined){
            value = operator
            operator = "="
        }
        if(this.sql.indexOf("where") != -1){
            this.sql.push("and")
        }else{
            this.sql.push("where")
        }
        this.sql.push(this.bracket)
        this.bracket = ""
        this.sql.push("`"+column+"`")
        this.sql.push(operator)
        this.sql.push("?")
        this.param.push(value)
        return this
    }

    or(column,operator,value){
        if(value == undefined){
            value = operator
            operator = "="
        }        
        this.sql.push("or")
        this.sql.push(this.bracket)
        this.bracket = ""
        this.sql.push("`"+column+"`")
        this.sql.push(operator)
        this.sql.push("?")
        this.param.push(value)
        return this
    }

    openBrackets(){
        this.bracket = "("
        return this
    }

    closeBrackets(){
        this.sql.push(")")
        return this
    }

    limit(skip,limit){                
        this.sql.push("limit")
        this.sql.push(skip)
        if(limit !== undefined)
            this.sql.push(",")
        this.sql.push(limit)

        return this
    }

    groupBy(columns){
        let table = new this.class().$table
        this.sql.push("group by")
        if(typeof columns == "string"){
            columns = "`" +table+ "`." + "`" + columns + "`"
        }else{
            columns.forEach((e,i)=>{columns[i] ="`" +table+ "`." +  "`"+e+"`"})
        }
        this.sql.push((typeof columns == "string"?columns:columns.join(",")))
        return this
    }

    join(table, col1, col2, typeJoin = "inner join"){
        let table2 = new this.class().$table
        this.sql.push(typeJoin)
        this.sql.push("`"+table+"`")
        this.sql.push("on")
        this.sql.push("`"+table2+"`.`"+col1+"`")
        this.sql.push("=")
        this.sql.push("`"+table+"`.`"+col2+"`")
    }

    orderBy(column,type = "asc"){
        this.sql.push("order by")
        this.sql.push(column)
        this.sql.push(type)
        return this
    }

    async find (id){
        let primaryKey = new this.class().$primaryKey
        if(typeof primaryKey == "string"){
            this.where(primaryKey,id)
        }            
        else{
            primaryKey.forEach((e,i)=>{
                this.where(e,id[i])
            })
        }
        let rs = await this.limit(1).select()
        return rs.shift()
    }
    async first (select = "*"){
        let rs = await this.limit(1).select(select)
        return rs[0]
    }

    async SQLCommand (sql,param){
        let rs = []
        let data = await Connected(sql,param)
        data[0].forEach(element => {
            let model = new this.class()
            for (const [key, value] of Object.entries(element)) {
                model[key] = value
            }
            rs.push(model)
        });
        return rs
    }
}

module.exports = Context